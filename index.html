<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CQ Line Pilot Comments</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f7fb;
      --card: #ffffff;
      --text: #1b1f2a;
      --muted: #5d657a;
      --accent: #2f6fed;
      --border: #e2e6f0;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    header {
      padding: 32px 24px 12px;
      background: linear-gradient(120deg, #1d4ed8, #3b82f6);
      color: #fff;
    }

    header h1 {
      margin: 0 0 8px;
      font-size: clamp(1.6rem, 2vw, 2.2rem);
    }

    header p {
      margin: 0;
      opacity: 0.9;
    }

    main {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: end;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      margin-top: -40px;
      box-shadow: 0 12px 32px rgba(15, 23, 42, 0.12);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 200px;
      flex: 1;
    }

    .control-group label {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .control-group input {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
    }

    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .manual-input {
      margin-top: 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      display: none !important;
      gap: 12px;
    }

    .manual-input textarea {
      width: 100%;
      min-height: 160px;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 12px;
      font-family: "SFMono-Regular", "Menlo", "Consolas", monospace;
      font-size: 0.85rem;
      resize: vertical;
    }

    .manual-input input[type="url"] {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
      width: 100%;
    }

    button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 10px 16px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    button.secondary {
      background: #e2e8f0;
      color: #1e293b;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .status {
      margin: 20px 0 12px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .cards {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.06);
    }

    .card h3 {
      margin: 0;
      font-size: 1rem;
      color: #0f172a;
    }

    .card time {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .card p {
      margin: 0;
      color: #1e293b;
      line-height: 1.5;
    }

    .tag {
      background: #e0ecff;
      color: #1d4ed8;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      display: inline-flex;
      align-items: center;
      width: fit-content;
    }

    .expandable button {
      align-self: flex-start;
      background: transparent;
      color: var(--accent);
      padding: 0;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 20;
    }

    .modal.is-open {
      display: flex;
    }

    .modal-content {
      background: var(--card);
      border-radius: 18px;
      max-width: 920px;
      width: 100%;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border);
      box-shadow: 0 20px 50px rgba(15, 23, 42, 0.25);
    }

    .modal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
      padding: 20px 24px 12px;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.2rem;
      color: #0f172a;
    }

    .modal-body {
      padding: 0 24px 24px;
      overflow-y: auto;
    }

    .modal-body p {
      white-space: pre-wrap;
      line-height: 1.65;
      color: #1e293b;
    }

    .modal-close {
      background: transparent;
      color: var(--muted);
      font-size: 1.2rem;
      padding: 0;
    }

    .modal-meta {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-top: 6px;
      color: var(--muted);
      font-size: 0.85rem;
    }

    .empty {
      padding: 40px;
      text-align: center;
      color: var(--muted);
      border: 2px dashed var(--border);
      border-radius: 16px;
    }

    @media (max-width: 600px) {
      header {
        padding: 28px 18px 16px;
      }

      main {
        padding: 18px;
      }

      .controls {
        margin-top: -24px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>CQ Line Pilot Intel</h1>
    <p>Filter and review the latest CQ line pilot comments in a cleaner, responsive layout.</p>
  </header>
  <main>
    <section class="controls">
      <div class="control-group">
        <label for="startDate">Start date</label>
        <input type="date" id="startDate" />
      </div>
      <div class="control-group">
        <label for="endDate">End date</label>
        <input type="date" id="endDate" />
      </div>
      <div class="actions">
        <button id="applyFilters">Apply filters</button>
        <button id="resetFilters" class="secondary">Reset</button>
      </div>
    </section>
    <section class="manual-input">
      <div class="control-group">
        <label for="sourceUrl">Fetch HTML from a URL (optional)</label>
        <input
          type="url"
          id="sourceUrl"
          placeholder="http://www.airbusdriver.net/airbus_CQT_Intel.htm"
          value="http://www.airbusdriver.net/airbus_CQT_Intel.htm"
        />
        <small class="status">If the request is blocked by CORS, download the HTML and paste it below.</small>
      </div>
      <div class="actions">
        <button id="fetchUrl" class="secondary">Fetch URL</button>
      </div>
      <div class="control-group">
        <label for="manualHtml">Paste HTML from the target page</label>
        <textarea id="manualHtml" placeholder="Paste the HTML source for http://www.airbusdriver.net/airbus_CQT_Intel.htm"></textarea>
      </div>
      <div class="actions">
        <button id="parseHtml" class="secondary">Parse pasted HTML</button>
      </div>
    </section>

    <div class="status" id="status">Paste the HTML source to load entries.</div>
    <section class="cards" id="cards"></section>
  </main>

  <div class="modal" id="entryModal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal-header">
        <div>
          <h2 id="modalTitle">Entry details</h2>
          <div class="modal-meta" id="modalMeta"></div>
        </div>
        <button class="modal-close" id="closeModal" type="button" aria-label="Close full entry">
          ✕
        </button>
      </div>
      <div class="modal-body">
        <p id="modalBody"></p>
      </div>
    </div>
  </div>

  <script>
    const statusEl = document.getElementById("status");
    const cardsEl = document.getElementById("cards");
    const startDateEl = document.getElementById("startDate");
    const endDateEl = document.getElementById("endDate");
    const applyFiltersBtn = document.getElementById("applyFilters");
    const resetFiltersBtn = document.getElementById("resetFilters");
    const fetchUrlBtn = document.getElementById("fetchUrl");
    const sourceUrlEl = document.getElementById("sourceUrl");
    const parseHtmlBtn = document.getElementById("parseHtml");
    const manualHtmlEl = document.getElementById("manualHtml");

    // Initialize date inputs with calculated values
    const initializeDateInputs = () => {
      const today = new Date();

      // endDate: current date in user's local time
      const endDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const endDateString = endDate.toISOString().split('T')[0];
      endDateEl.value = endDateString;

      // startDate: December 1st of previous year
      const startDate = new Date(today.getFullYear() - 1, 11, 1); // Month is 0-indexed, so 11 = December
      const startDateString = startDate.toISOString().split('T')[0];
      startDateEl.value = startDateString;
    };

    // Call initialization immediately
    initializeDateInputs();

    const PROXY_URL = "https://snowy-king-2ff2.phantomworx.workers.dev/";
    const entryModalEl = document.getElementById("entryModal");
    const closeModalBtn = document.getElementById("closeModal");
    const modalTitleEl = document.getElementById("modalTitle");
    const modalMetaEl = document.getElementById("modalMeta");
    const modalBodyEl = document.getElementById("modalBody");

    let allEntries = [];

    const markerText = "Your CQ Line Pilot Comments will be placed here ...";

    const normalizeWhitespace = (value) =>
      value.replace(/\s+/g, " ").trim();

    const cleanDateText = (text) =>
      text
        .replace(/\([^)]*\)/g, "")
        .replace(/\s+/g, " ")
        .trim();

    const parseDate = (text) => {
      if (!text) {
        return null;
      }

      const cleanedText = cleanDateText(text);
      let parsed = new Date(cleanedText);
      if (!Number.isNaN(parsed.getTime())) {
        return parsed;
      }

      const numericOnly = cleanedText.replace(/[^0-9/.-]/g, "").trim();
      if (!numericOnly) {
        return null;
      }

      parsed = new Date(numericOnly);
      if (!Number.isNaN(parsed.getTime())) {
        return parsed;
      }

      const match = numericOnly.match(/(\d{1,2})[\/.-](\d{1,2})[\/.-](\d{2,4})/);
      if (match) {
        const month = Number(match[1]);
        const day = Number(match[2]);
        let year = Number(match[3]);
        if (year < 100) {
          year += 2000;
        }
        parsed = new Date(year, month - 1, day);
        if (!Number.isNaN(parsed.getTime())) {
          return parsed;
        }
      }

      const monthYear = numericOnly.match(/(\d{1,2})[\/.-](\d{4})/);
      if (monthYear) {
        const month = Number(monthYear[1]);
        const year = Number(monthYear[2]);
        parsed = new Date(year, month - 1, 1);
        if (!Number.isNaN(parsed.getTime())) {
          return parsed;
        }
      }

      return null;
    };

    const formatDate = (date, fallback) => {
      if (!date) {
        return fallback || "Unknown date";
      }
      return date.toLocaleDateString(undefined, {
        year: "numeric",
        month: "short",
        day: "2-digit",
      });
    };

    const getEntriesFromDocument = (doc) => {
      const rows = Array.from(doc.querySelectorAll("tr"));
      const markerIndex = rows.findIndex((row) =>
        normalizeWhitespace(row.textContent).includes(markerText)
      );

      if (markerIndex === -1) {
        return [];
      }

      const entries = [];
      const dataRows = rows.slice(markerIndex + 1);

      dataRows.forEach((row) => {
        const strong = row.querySelector("strong");
        if (!strong) {
          return;
        }

        const dateText = normalizeWhitespace(strong.textContent);
        const date = parseDate(dateText);
        
        if (!date) {
          return;
        }

        // Extract content preserving <br> as newlines
        let content = row.innerHTML;
        // Remove the strong element from the content
        const strongHtml = strong.outerHTML;
        content = content.replace(strongHtml, "").trim();
        
        // Use a placeholder for <br> tags to preserve them
        const BR_PLACEHOLDER = "|||BREAK|||";
        content = content.replace(/<br\s*\/?>/gi, BR_PLACEHOLDER);
        
        // Remove all remaining HTML tags
        content = content.replace(/<[^>]*>/g, "");
        
        // Split by the break placeholder to handle each segment
        const segments = content.split(BR_PLACEHOLDER);
        
        // Clean each segment but keep empty ones (for double breaks)
        const cleanedSegments = segments
          .map((segment) => normalizeWhitespace(segment));
        
        // Rejoin with newlines, preserving empty segments for double breaks
        content = cleanedSegments.join("\n").trim();

        if (!content) {
          return;
        }

        entries.push({
          dateText,
          date,
          content,
        });
      });

      return entries;
    };

    const parseEntriesFromHtml = (html) => {
      const doc = new DOMParser().parseFromString(html, "text/html");
      return getEntriesFromDocument(doc);
    };

    const fetchHtmlFromUrl = async (url) => {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch (${response.status} ${response.statusText})`);
      }
      return response.text();
    };

    const describeFetchError = (error, url) => {
      const reason = error instanceof Error ? error.message : String(error);
      return `Unable to fetch ${url}. ${reason}. This is often caused by CORS or a blocked origin.`;
    };

    // Fallback removed — proxy will be used for all fetches

    const buildProxyUrl = (proxyBase, targetUrl) => {
      const trimmed = proxyBase.trim();
      if (!trimmed) {
        return null;
      }
      if (trimmed.includes("?")) {
        return `${trimmed}${encodeURIComponent(targetUrl)}`;
      }
      return `${trimmed}?url=${encodeURIComponent(targetUrl)}`;
    };

    const fetchWithProxy = async (targetUrl) => {
      const proxyUrl = buildProxyUrl(PROXY_URL, targetUrl);
      if (!proxyUrl) {
        throw new Error("No proxy URL configured.");
      }
      return fetchHtmlFromUrl(proxyUrl);
    };

    const isWithinRange = (entry) => {
      const startValue = startDateEl.value ? new Date(startDateEl.value) : null;
      const endValue = endDateEl.value ? new Date(endDateEl.value) : null;

      if (!startValue && !endValue) {
        return true;
      }

      if (!entry.date) {
        return true;
      }

      if (startValue && entry.date < startValue) {
        return false;
      }

      if (endValue) {
        const inclusiveEnd = new Date(endValue);
        inclusiveEnd.setHours(23, 59, 59, 999);
        if (entry.date > inclusiveEnd) {
          return false;
        }
      }

      return true;
    };

    const createCard = (entry) => {
      const card = document.createElement("article");
      card.className = "card";

      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = entry.dateText || "Unknown date";

      const textWrap = document.createElement("div");
      textWrap.className = "expandable";

      const paragraph = document.createElement("p");
      const fullText = entry.content;
      const maxLength = 260;

      // Show the first few lines (up to 3) as the card preview
      const updateText = () => {
        const lines = fullText.split("\n");
        const preview = lines.slice(0, 3).join("\n");
        let text = preview;
        if (text.length > maxLength) {
          text = `${text.slice(0, maxLength).trim()}…`;
        }
        paragraph.textContent = text;
        paragraph.style.whiteSpace = "pre-wrap";
      };

      updateText();

      textWrap.appendChild(paragraph);

      const expandBtn = document.createElement("button");
      expandBtn.type = "button";
      expandBtn.textContent = "View full report";
      expandBtn.addEventListener("click", () => openModal(entry));
      textWrap.appendChild(expandBtn);
      // Make entire card clickable to open modal
card.addEventListener("click", (e) => {
  // Don't trigger if clicking the button (it has its own handler)
  if (e.target !== expandBtn) {
    openModal(entry);
  }
});
card.style.cursor = "pointer";

      card.appendChild(tag);
      card.appendChild(textWrap);

      return card;
    };

    const openModal = (entry) => {
      modalTitleEl.textContent = entry.dateText || "Full entry";
      modalMetaEl.textContent = formatDate(entry.date, entry.dateText);
      // Clear previous content
      modalBodyEl.textContent = "";
      // Add content with preserved newlines (including empty lines for double breaks)
      const lines = entry.content.split("\n");
      lines.forEach((line, index) => {
        if (index > 0) {
          modalBodyEl.appendChild(document.createElement("br"));
        }
        // Add text node even if line is empty (for double <br> support)
        if (line.length > 0) {
          modalBodyEl.appendChild(document.createTextNode(line));
        }
      });
      entryModalEl.classList.add("is-open");
      entryModalEl.setAttribute("aria-hidden", "false");
    };

    const closeModal = () => {
      entryModalEl.classList.remove("is-open");
      entryModalEl.setAttribute("aria-hidden", "true");
    };

    const renderEntries = () => {
      const visibleEntries = allEntries.filter(isWithinRange);
      statusEl.textContent = `${visibleEntries.length} entries loaded.`;

      if (visibleEntries.length === 0) {
        cardsEl.innerHTML = `
          <div class="empty">
            No entries match the selected date range.
          </div>
        `;
        return;
      }

      cardsEl.innerHTML = "";
      visibleEntries.forEach((entry) => {
        cardsEl.appendChild(createCard(entry));
      });
    };

    applyFiltersBtn.addEventListener("click", renderEntries);
    resetFiltersBtn.addEventListener("click", () => {
      startDateEl.value = "";
      endDateEl.value = "";
      renderEntries();
    });
    const fetchAndLoad = async (url) => {
      const trimmed = url ? url.trim() : "";
      if (!trimmed) {
        statusEl.textContent = "Enter a URL to fetch.";
        return;
      }
      statusEl.textContent = "Fetching HTML…";
      try {
        const html = await fetchHtmlFromUrl(trimmed);
        manualHtmlEl.value = html;
        allEntries = parseEntriesFromHtml(html);
        renderEntries();
        return;
      } catch (error) {
        statusEl.textContent = `${describeFetchError(error, trimmed)} Attempting proxy fetch…`;
        console.error(error);
        try {
          const html = await fetchWithProxy(trimmed);
          manualHtmlEl.value = html;
          allEntries = parseEntriesFromHtml(html);
          renderEntries();
          return;
        } catch (proxyError) {
          statusEl.textContent = `${describeFetchError(proxyError, buildProxyUrl(PROXY_URL, trimmed) || "proxy URL")} Paste the HTML source instead.`;
          console.error(proxyError);
        }
      }
    };

    fetchUrlBtn.addEventListener("click", async () => {
      await fetchAndLoad(sourceUrlEl.value);
    });

    // Auto-fetch on page load using the configured source URL
    window.addEventListener("load", () => {
      try {
        const url = sourceUrlEl && sourceUrlEl.value ? sourceUrlEl.value.trim() : "";
        if (url) {
          fetchAndLoad(url);
        }
      } catch (e) {
        console.error("Auto-fetch failed:", e);
      }
    });
    parseHtmlBtn.addEventListener("click", () => {
      const html = manualHtmlEl.value.trim();
      if (!html) {
        statusEl.textContent = "Paste the HTML source to parse it.";
        return;
      }
      allEntries = parseEntriesFromHtml(html);
      renderEntries();
    });
    closeModalBtn.addEventListener("click", closeModal);
    entryModalEl.addEventListener("click", (event) => {
      if (event.target === entryModalEl) {
        closeModal();
      }
    });
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && entryModalEl.classList.contains("is-open")) {
        closeModal();
      }
    });
  </script>
</body>
</html>
