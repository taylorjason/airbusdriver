<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CQ Line Pilot Comments</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f7fb;
      --card: #ffffff;
      --text: #1b1f2a;
      --muted: #5d657a;
      --accent: #2f6fed;
      --border: #e2e6f0;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    header {
      padding: 32px 24px 12px;
      background: linear-gradient(120deg, #1d4ed8, #3b82f6);
      color: #fff;
    }

    header h1 {
      margin: 0 0 8px;
      font-size: clamp(1.6rem, 2vw, 2.2rem);
    }

    header p {
      margin: 0;
      opacity: 0.9;
    }

    main {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: end;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      margin-top: -40px;
      box-shadow: 0 12px 32px rgba(15, 23, 42, 0.12);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 200px;
      flex: 1;
    }

    .control-group label {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .control-group input,
    .control-group select {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
    }

    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .manual-input {
      margin-top: 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      display: none !important;
      gap: 12px;
    }

    .manual-input textarea {
      width: 100%;
      min-height: 160px;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 12px;
      font-family: "SFMono-Regular", "Menlo", "Consolas", monospace;
      font-size: 0.85rem;
      resize: vertical;
    }

    .manual-input input[type="url"] {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
      width: 100%;
    }

    button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 10px 16px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
    }

    button.secondary {
      background: #e2e8f0;
      color: #1e293b;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .status {
      margin: 20px 0 12px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .cards {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.06);
    }

    .card h3 {
      margin: 0;
      font-size: 1rem;
      color: #0f172a;
    }

    .card time {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .card p {
      margin: 0;
      color: #1e293b;
      line-height: 1.5;
    }

    .tag {
      background: #e0ecff;
      color: #1d4ed8;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      display: inline-flex;
      align-items: center;
      width: fit-content;
    }

    .expandable button {
      align-self: flex-start;
      background: transparent;
      color: var(--accent);
      padding: 0;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 20;
    }

    .modal.is-open {
      display: flex;
    }

    .modal-content {
      background: var(--card);
      border-radius: 18px;
      max-width: 920px;
      width: 100%;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border);
      box-shadow: 0 20px 50px rgba(15, 23, 42, 0.25);
    }

    .modal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
      padding: 20px 24px 12px;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.2rem;
      color: #0f172a;
    }

    .modal-body {
      padding: 0 24px 24px;
      overflow-y: auto;
    }

    .modal-body p {
      white-space: pre-wrap;
      line-height: 1.65;
      color: #1e293b;
    }

    .modal-close {
      background: transparent;
      color: var(--muted);
      font-size: 1.2rem;
      padding: 0;
    }

    .modal-meta {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-top: 6px;
      color: var(--muted);
      font-size: 0.85rem;
    }

    .empty {
      padding: 40px;
      text-align: center;
      color: var(--muted);
      border: 2px dashed var(--border);
      border-radius: 16px;
    }

    .cache-info {
      margin-top: 32px;
      padding-top: 24px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    .cache-status {
      font-size: 0.85rem;
      color: var(--muted);
      text-align: center;
    }

    .refresh-btn {
      background: transparent;
      color: var(--muted);
      border: 1px solid var(--border);
      padding: 8px 14px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .refresh-btn:hover {
      background: var(--border);
      color: var(--text);
    }

    @media (max-width: 600px) {
      header {
        padding: 28px 18px 16px;
      }

      main {
        padding: 18px;
      }

      .controls {
        margin-top: -24px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>CQ Line Pilot Intel</h1>
    <p>Filter and review the latest CQ line pilot comments in a cleaner, responsive layout.</p>
  </header>
  <main>
    <section class="controls">
      <div class="control-group">
        <label for="startDate">Start date</label>
        <input type="date" id="startDate" />
      </div>
      <div class="control-group">
        <label for="endDate">End date</label>
        <input type="date" id="endDate" />
      </div>
      <div class="control-group">
        <label for="sortOrder">Sort by date</label>
        <select id="sortOrder">
          <option value="newest">Newest first</option>
          <option value="oldest">Oldest first</option>
        </select>
      </div>
      <div class="actions">
        <button id="applyFilters">Apply filters</button>
        <button id="resetFilters" class="secondary">Reset</button>
      </div>
    </section>
    <section class="manual-input">
      <div class="control-group">
        <label for="sourceUrl">Fetch HTML from a URL (optional)</label>
        <input
          type="url"
          id="sourceUrl"
          placeholder="http://www.airbusdriver.net/airbus_CQT_Intel.htm"
          value="http://www.airbusdriver.net/airbus_CQT_Intel.htm"
        />
        <small class="status">If the request is blocked by CORS, download the HTML and paste it below.</small>
      </div>
      <div class="actions">
        <button id="fetchUrl" class="secondary">Fetch URL</button>
      </div>
      <div class="control-group">
        <label for="manualHtml">Paste HTML from the target page</label>
        <textarea id="manualHtml" placeholder="Paste the HTML source for http://www.airbusdriver.net/airbus_CQT_Intel.htm"></textarea>
      </div>
      <div class="actions">
        <button id="parseHtml" class="secondary">Parse pasted HTML</button>
      </div>
    </section>

    <div class="status" id="status">Paste the HTML source to load entries.</div>
    <section class="cards" id="cards"></section>

    <footer class="cache-info">
      <div id="cacheStatus" class="cache-status"></div>
      <button id="refreshDataBtn" class="refresh-btn" style="display: none;">Refresh Data</button>
    </footer>
  </main>

  <div class="modal" id="entryModal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal-header">
        <div>
          <h2 id="modalTitle">Entry details</h2>
          <div class="modal-meta" id="modalMeta"></div>
        </div>
        <button class="modal-close" id="closeModal" type="button" aria-label="Close full entry">
          ✕
        </button>
      </div>
      <div class="modal-body">
        <p id="modalBody"></p>
      </div>
    </div>
  </div>

  <script>
    const statusEl = document.getElementById("status");
    const cardsEl = document.getElementById("cards");
    const startDateEl = document.getElementById("startDate");
    const endDateEl = document.getElementById("endDate");
    const sortOrderEl = document.getElementById("sortOrder");
    const applyFiltersBtn = document.getElementById("applyFilters");
    const resetFiltersBtn = document.getElementById("resetFilters");
    const fetchUrlBtn = document.getElementById("fetchUrl");
    const sourceUrlEl = document.getElementById("sourceUrl");
    const parseHtmlBtn = document.getElementById("parseHtml");
    const manualHtmlEl = document.getElementById("manualHtml");

    // Initialize date inputs with calculated values
    const initializeDateInputs = () => {
      const today = new Date();

      // endDate: current date in user's local time
      const endDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const endDateString = endDate.toISOString().split('T')[0];
      endDateEl.value = endDateString;

      // startDate: December 1st of previous year
      const startDate = new Date(today.getFullYear() - 1, 11, 1); // Month is 0-indexed, so 11 = December
      const startDateString = startDate.toISOString().split('T')[0];
      startDateEl.value = startDateString;
    };

    // Call initialization immediately
    initializeDateInputs();

    // Sort preference persistence
    const SORT_PREFERENCE_KEY = "airbusdriver_sort_preference";

    const loadSortPreference = () => {
      try {
        const savedSort = localStorage.getItem(SORT_PREFERENCE_KEY);
        if (savedSort && sortOrderEl) {
          sortOrderEl.value = savedSort;
        }
      } catch (e) {
        console.error('[Sort] Failed to load sort preference:', e);
      }
    };

    const saveSortPreference = (value) => {
      try {
        localStorage.setItem(SORT_PREFERENCE_KEY, value);
      } catch (e) {
        console.error('[Sort] Failed to save sort preference:', e);
      }
    };

    // Load saved sort preference
    loadSortPreference();

    const PROXY_URL = "https://snowy-king-2ff2.phantomworx.workers.dev/";
    const entryModalEl = document.getElementById("entryModal");
    const closeModalBtn = document.getElementById("closeModal");
    const modalTitleEl = document.getElementById("modalTitle");
    const modalMetaEl = document.getElementById("modalMeta");
    const modalBodyEl = document.getElementById("modalBody");

    let allEntries = [];
    let lastCachedTimestamp = null;

    const markerText = "Your CQ Line Pilot Comments will be placed here ...";

    // Cache configuration
    const CACHE_KEY = "airbusdriver_cache";
    const CACHE_EXPIRATION_MS = 24 * 60 * 60 * 1000; // 24 hours
    const DOUBLE_REFRESH_THRESHOLD_MS = 15 * 1000; // 15 seconds

    // localStorage cache functions
    const saveToCache = (html, entries, sourceUrl) => {
      try {
        const cacheData = {
          html,
          entries,
          timestamp: Date.now(),
          sourceUrl
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
        lastCachedTimestamp = cacheData.timestamp;
        updateCacheStatus();
        console.log('[Cache] Data saved to localStorage');
      } catch (e) {
        console.error('[Cache] Failed to save to localStorage:', e);
      }
    };

    const loadFromCache = () => {
      try {
        const cached = localStorage.getItem(CACHE_KEY);
        if (!cached) {
          console.log('[Cache] No cached data found');
          return null;
        }

        const cacheData = JSON.parse(cached);

        // Validate cache structure
        if (!cacheData.timestamp || !cacheData.html || !cacheData.entries) {
          console.log('[Cache] Invalid cache structure');
          return null;
        }

        // Check if cache is expired
        const age = Date.now() - cacheData.timestamp;
        if (age > CACHE_EXPIRATION_MS) {
          console.log('[Cache] Cache expired (age: ' + Math.round(age / 1000 / 60) + ' minutes)');
          return null;
        }

        // Rehydrate Date objects (JSON.stringify converts them to strings)
        cacheData.entries = cacheData.entries.map(entry => ({
          ...entry,
          date: entry.date ? new Date(entry.date) : null
        }));

        console.log('[Cache] Using cached data (age: ' + Math.round(age / 1000 / 60) + ' minutes)');
        lastCachedTimestamp = cacheData.timestamp;
        return cacheData;
      } catch (e) {
        console.error('[Cache] Failed to load from localStorage:', e);
        return null;
      }
    };

    const clearCache = () => {
      try {
        localStorage.removeItem(CACHE_KEY);
        lastCachedTimestamp = null;
        console.log('[Cache] Cache cleared');
      } catch (e) {
        console.error('[Cache] Failed to clear cache:', e);
      }
    };

    // sessionStorage double-refresh detection
    const checkDoubleRefresh = () => {
      try {
        const lastFetchTime = sessionStorage.getItem('lastFetchTime');
        const now = Date.now();

        if (lastFetchTime) {
          const timeSinceLastFetch = now - parseInt(lastFetchTime, 10);
          if (timeSinceLastFetch < DOUBLE_REFRESH_THRESHOLD_MS) {
            console.log('[Cache] Double-refresh detected! Forcing cache bypass.');
            return true;
          }
        }

        sessionStorage.setItem('lastFetchTime', now.toString());
        return false;
      } catch (e) {
        console.error('[Cache] Failed to check double-refresh:', e);
        return false;
      }
    };

    // Update cache status UI
    const updateCacheStatus = () => {
      const cacheStatusEl = document.getElementById('cacheStatus');
      const refreshBtn = document.getElementById('refreshDataBtn');

      if (!cacheStatusEl) return;

      if (lastCachedTimestamp) {
        const age = Date.now() - lastCachedTimestamp;
        const hours = Math.floor(age / 1000 / 60 / 60);
        const minutes = Math.floor((age / 1000 / 60) % 60);

        let ageText;
        if (hours > 0) {
          ageText = `${hours} hour${hours !== 1 ? 's' : ''}`;
          if (minutes > 0) {
            ageText += ` ${minutes} min`;
          }
        } else if (minutes > 0) {
          ageText = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
        } else {
          ageText = 'just now';
        }

        cacheStatusEl.textContent = `Last updated: ${ageText} ago`;
        if (refreshBtn) {
          refreshBtn.style.display = 'inline-block';
        }
      } else {
        cacheStatusEl.textContent = '';
        if (refreshBtn) {
          refreshBtn.style.display = 'none';
        }
      }
    };

    const normalizeWhitespace = (value) =>
      value.replace(/\s+/g, " ").trim();

    const cleanDateText = (text) =>
      text
        .replace(/\([^)]*\)/g, "")
        .replace(/\s+/g, " ")
        .trim();

    const parseDate = (text) => {
      if (!text) {
        return null;
      }

      const cleanedText = cleanDateText(text);
      let parsed = new Date(cleanedText);
      if (!Number.isNaN(parsed.getTime())) {
        return parsed;
      }

      const numericOnly = cleanedText.replace(/[^0-9/.-]/g, "").trim();
      if (!numericOnly) {
        return null;
      }

      parsed = new Date(numericOnly);
      if (!Number.isNaN(parsed.getTime())) {
        return parsed;
      }

      const match = numericOnly.match(/(\d{1,2})[\/.-](\d{1,2})[\/.-](\d{2,4})/);
      if (match) {
        const month = Number(match[1]);
        const day = Number(match[2]);
        let year = Number(match[3]);
        if (year < 100) {
          year += 2000;
        }
        parsed = new Date(year, month - 1, day);
        if (!Number.isNaN(parsed.getTime())) {
          return parsed;
        }
      }

      const monthYear = numericOnly.match(/(\d{1,2})[\/.-](\d{4})/);
      if (monthYear) {
        const month = Number(monthYear[1]);
        const year = Number(monthYear[2]);
        parsed = new Date(year, month - 1, 1);
        if (!Number.isNaN(parsed.getTime())) {
          return parsed;
        }
      }

      return null;
    };

    const formatDate = (date, fallback) => {
      if (!date) {
        return fallback || "Unknown date";
      }
      return date.toLocaleDateString(undefined, {
        year: "numeric",
        month: "short",
        day: "2-digit",
      });
    };

    const getEntriesFromDocument = (doc) => {
      const rows = Array.from(doc.querySelectorAll("tr"));
      const markerIndex = rows.findIndex((row) =>
        normalizeWhitespace(row.textContent).includes(markerText)
      );

      if (markerIndex === -1) {
        return [];
      }

      const entries = [];
      const dataRows = rows.slice(markerIndex + 1);

      dataRows.forEach((row) => {
        const strong = row.querySelector("strong");
        if (!strong) {
          return;
        }

        const dateText = normalizeWhitespace(strong.textContent);
        const date = parseDate(dateText);
        
        if (!date) {
          return;
        }

        // Extract content preserving <br> as newlines
        let content = row.innerHTML;
        // Remove the strong element from the content
        const strongHtml = strong.outerHTML;
        content = content.replace(strongHtml, "").trim();
        
        // Use a placeholder for <br> tags to preserve them
        const BR_PLACEHOLDER = "|||BREAK|||";
        content = content.replace(/<br\s*\/?>/gi, BR_PLACEHOLDER);
        
        // Remove all remaining HTML tags
        content = content.replace(/<[^>]*>/g, "");
        
        // Split by the break placeholder to handle each segment
        const segments = content.split(BR_PLACEHOLDER);
        
        // Clean each segment but keep empty ones (for double breaks)
        const cleanedSegments = segments
          .map((segment) => normalizeWhitespace(segment));
        
        // Rejoin with newlines, preserving empty segments for double breaks
        content = cleanedSegments.join("\n").trim();

        if (!content) {
          return;
        }

        entries.push({
          dateText,
          date,
          content,
        });
      });

      return entries;
    };

    const parseEntriesFromHtml = (html) => {
      const doc = new DOMParser().parseFromString(html, "text/html");
      return getEntriesFromDocument(doc);
    };

    const fetchHtmlFromUrl = async (url) => {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch (${response.status} ${response.statusText})`);
      }
      return response.text();
    };

    const describeFetchError = (error, url) => {
      const reason = error instanceof Error ? error.message : String(error);
      return `Unable to fetch ${url}. ${reason}. This is often caused by CORS or a blocked origin.`;
    };

    // Fallback removed — proxy will be used for all fetches

    const buildProxyUrl = (proxyBase, targetUrl) => {
      const trimmed = proxyBase.trim();
      if (!trimmed) {
        return null;
      }
      if (trimmed.includes("?")) {
        return `${trimmed}${encodeURIComponent(targetUrl)}`;
      }
      return `${trimmed}?url=${encodeURIComponent(targetUrl)}`;
    };

    const fetchWithProxy = async (targetUrl, forceRefresh = false) => {
      const proxyUrl = buildProxyUrl(PROXY_URL, targetUrl);
      if (!proxyUrl) {
        throw new Error("No proxy URL configured.");
      }

      // Add Cache-Control header for force refresh
      const headers = forceRefresh ? { 'Cache-Control': 'no-cache' } : {};

      const response = await fetch(proxyUrl, { headers });
      if (!response.ok) {
        throw new Error(`Failed to fetch (${response.status} ${response.statusText})`);
      }
      return response.text();
    };

    const isWithinRange = (entry) => {
      const startValue = startDateEl.value ? new Date(startDateEl.value) : null;
      const endValue = endDateEl.value ? new Date(endDateEl.value) : null;

      if (!startValue && !endValue) {
        return true;
      }

      if (!entry.date) {
        return true;
      }

      if (startValue && entry.date < startValue) {
        return false;
      }

      if (endValue) {
        const inclusiveEnd = new Date(endValue);
        inclusiveEnd.setHours(23, 59, 59, 999);
        if (entry.date > inclusiveEnd) {
          return false;
        }
      }

      return true;
    };

    const createCard = (entry) => {
      const card = document.createElement("article");
      card.className = "card";

      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = entry.dateText || "Unknown date";

      const textWrap = document.createElement("div");
      textWrap.className = "expandable";

      const paragraph = document.createElement("p");
      const fullText = entry.content;
      const maxLength = 260;

      // Show the first few lines (up to 3) as the card preview
      const updateText = () => {
        const lines = fullText.split("\n");
        const preview = lines.slice(0, 3).join("\n");
        let text = preview;
        if (text.length > maxLength) {
          text = `${text.slice(0, maxLength).trim()}…`;
        }
        paragraph.textContent = text;
        paragraph.style.whiteSpace = "pre-wrap";
      };

      updateText();

      textWrap.appendChild(paragraph);

      const expandBtn = document.createElement("button");
      expandBtn.type = "button";
      expandBtn.textContent = "View full report";
      expandBtn.addEventListener("click", () => openModal(entry));
      textWrap.appendChild(expandBtn);
      // Make entire card clickable to open modal
card.addEventListener("click", (e) => {
  // Don't trigger if clicking the button (it has its own handler)
  if (e.target !== expandBtn) {
    openModal(entry);
  }
});
card.style.cursor = "pointer";

      card.appendChild(tag);
      card.appendChild(textWrap);

      return card;
    };

    const openModal = (entry) => {
      modalTitleEl.textContent = entry.dateText || "Full entry";
      modalMetaEl.textContent = formatDate(entry.date, entry.dateText);
      // Clear previous content
      modalBodyEl.textContent = "";
      // Add content with preserved newlines (including empty lines for double breaks)
      const lines = entry.content.split("\n");
      lines.forEach((line, index) => {
        if (index > 0) {
          modalBodyEl.appendChild(document.createElement("br"));
        }
        // Add text node even if line is empty (for double <br> support)
        if (line.length > 0) {
          modalBodyEl.appendChild(document.createTextNode(line));
        }
      });
      entryModalEl.classList.add("is-open");
      entryModalEl.setAttribute("aria-hidden", "false");
    };

    const closeModal = () => {
      entryModalEl.classList.remove("is-open");
      entryModalEl.setAttribute("aria-hidden", "true");
    };

    const renderEntries = () => {
      const visibleEntries = allEntries.filter(isWithinRange);

      // Apply sorting
      const sortOrder = sortOrderEl ? sortOrderEl.value : 'newest';
      visibleEntries.sort((a, b) => {
        // Handle entries without dates (should be rare, but just in case)
        if (!a.date && !b.date) return 0;
        if (!a.date) return 1; // Put entries without dates at the end
        if (!b.date) return -1;

        // Sort by date
        if (sortOrder === 'oldest') {
          return a.date - b.date; // Ascending (oldest first)
        } else {
          return b.date - a.date; // Descending (newest first)
        }
      });

      statusEl.textContent = `${visibleEntries.length} entries loaded.`;

      if (visibleEntries.length === 0) {
        cardsEl.innerHTML = `
          <div class="empty">
            No entries match the selected date range.
          </div>
        `;
        return;
      }

      cardsEl.innerHTML = "";
      visibleEntries.forEach((entry) => {
        cardsEl.appendChild(createCard(entry));
      });
    };

    applyFiltersBtn.addEventListener("click", renderEntries);
    resetFiltersBtn.addEventListener("click", () => {
      startDateEl.value = "";
      endDateEl.value = "";
      renderEntries();
    });

    // Handle sort order changes
    if (sortOrderEl) {
      sortOrderEl.addEventListener("change", () => {
        saveSortPreference(sortOrderEl.value);
        renderEntries();
      });
    }
    const fetchAndLoad = async (url, forceRefresh = false) => {
      const trimmed = url ? url.trim() : "";
      if (!trimmed) {
        statusEl.textContent = "Enter a URL to fetch.";
        return;
      }

      // Check for double-refresh (unless already forcing refresh)
      if (!forceRefresh) {
        forceRefresh = checkDoubleRefresh();
      }

      // Try to load from cache if not forcing refresh
      if (!forceRefresh) {
        const cached = loadFromCache();
        if (cached && cached.sourceUrl === trimmed) {
          console.log('[Cache] Loading from cache');
          manualHtmlEl.value = cached.html;
          allEntries = cached.entries;
          renderEntries();
          updateCacheStatus();
          return;
        }
      }

      // Cache miss or force refresh - fetch from network
      console.log('[Cache] Fetching from network' + (forceRefresh ? ' (forced)' : ''));
      statusEl.textContent = "Fetching HTML…";

      try {
        const html = await fetchHtmlFromUrl(trimmed);
        manualHtmlEl.value = html;
        allEntries = parseEntriesFromHtml(html);
        saveToCache(html, allEntries, trimmed);
        renderEntries();
        return;
      } catch (error) {
        statusEl.textContent = `${describeFetchError(error, trimmed)} Attempting proxy fetch…`;
        console.error(error);
        try {
          const html = await fetchWithProxy(trimmed, forceRefresh);
          manualHtmlEl.value = html;
          allEntries = parseEntriesFromHtml(html);
          saveToCache(html, allEntries, trimmed);
          renderEntries();
          return;
        } catch (proxyError) {
          statusEl.textContent = `${describeFetchError(proxyError, buildProxyUrl(PROXY_URL, trimmed) || "proxy URL")} Paste the HTML source instead.`;
          console.error(proxyError);
        }
      }
    };

    fetchUrlBtn.addEventListener("click", async () => {
      await fetchAndLoad(sourceUrlEl.value);
    });

    // Auto-fetch on page load using the configured source URL
    window.addEventListener("load", () => {
      try {
        const url = sourceUrlEl && sourceUrlEl.value ? sourceUrlEl.value.trim() : "";
        if (url) {
          fetchAndLoad(url);
        }
      } catch (e) {
        console.error("Auto-fetch failed:", e);
      }
    });
    parseHtmlBtn.addEventListener("click", () => {
      const html = manualHtmlEl.value.trim();
      if (!html) {
        statusEl.textContent = "Paste the HTML source to parse it.";
        return;
      }
      allEntries = parseEntriesFromHtml(html);
      renderEntries();
    });
    closeModalBtn.addEventListener("click", closeModal);
    entryModalEl.addEventListener("click", (event) => {
      if (event.target === entryModalEl) {
        closeModal();
      }
    });
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && entryModalEl.classList.contains("is-open")) {
        closeModal();
      }
    });

    // Refresh button handler
    const refreshDataBtn = document.getElementById('refreshDataBtn');
    if (refreshDataBtn) {
      refreshDataBtn.addEventListener('click', async () => {
        const url = sourceUrlEl && sourceUrlEl.value ? sourceUrlEl.value.trim() : "";
        if (url) {
          clearCache();
          await fetchAndLoad(url, true); // Force refresh
        }
      });
    }

    // Update cache status every minute
    setInterval(updateCacheStatus, 60000);
  </script>
</body>
</html>
