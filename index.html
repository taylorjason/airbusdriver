<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CQ Line Pilot Comments</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f7fb;
      --card: #ffffff;
      --text: #1b1f2a;
      --muted: #5d657a;
      --accent: #2f6fed;
      --border: #e2e6f0;
      --header-gradient-start: #1d4ed8;
      --header-gradient-end: #3b82f6;
      --modal-overlay: rgba(15, 23, 42, 0.55);
      --card-shadow: rgba(15, 23, 42, 0.06);
      --controls-shadow: rgba(15, 23, 42, 0.12);
      --modal-shadow: rgba(15, 23, 42, 0.25);
      --highlight-bg: #fef08a;
      --highlight-text: #854d0e;
      --error-bg: #fef2f2;
      --error-border: #fca5a5;
      --error-title: #991b1b;
      --error-text: #7f1d1d;
      --tag-bg: #e0ecff;
      --tag-text: #1d4ed8;
      --secondary-btn-bg: #e2e8f0;
      --secondary-btn-text: #1e293b;
    }

    :root[data-theme="dark"] {
      color-scheme: dark;
      --bg: #0f172a;
      --card: #1e293b;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #3b82f6;
      --border: #334155;
      --header-gradient-start: #1e3a8a;
      --header-gradient-end: #2563eb;
      --modal-overlay: rgba(0, 0, 0, 0.7);
      --card-shadow: rgba(0, 0, 0, 0.2);
      --controls-shadow: rgba(0, 0, 0, 0.3);
      --modal-shadow: rgba(0, 0, 0, 0.5);
      --highlight-bg: #854d0e;
      --highlight-text: #fef08a;
      --error-bg: #450a0a;
      --error-border: #7f1d1d;
      --error-title: #fca5a5;
      --error-text: #fca5a5;
      --tag-bg: #1e3a8a;
      --tag-text: #93c5fd;
      --secondary-btn-bg: #334155;
      --secondary-btn-text: #e2e8f0;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    header {
      padding: 32px 24px 12px;
      background: linear-gradient(120deg, var(--header-gradient-start), var(--header-gradient-end));
      color: #fff;
    }

    header h1 {
      margin: 0 0 8px;
      font-size: clamp(1.6rem, 2vw, 2.2rem);
    }

    header p {
      margin: 0;
      opacity: 0.9;
    }

    main {
      padding: 24px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: end;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-top: -40px;
      box-shadow: 0 12px 32px var(--controls-shadow);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 160px;
      flex: 1;
    }

    .control-group label {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .control-group input,
    .control-group select {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 0.9rem;
    }

    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .manual-input {
      margin-top: 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      display: none !important;
      gap: 12px;
    }

    .manual-input textarea {
      width: 100%;
      min-height: 160px;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 12px;
      font-family: "SFMono-Regular", "Menlo", "Consolas", monospace;
      font-size: 0.85rem;
      resize: vertical;
    }

    .manual-input input[type="url"] {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
      width: 100%;
    }

    button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 8px 14px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button.secondary {
      background: var(--secondary-btn-bg);
      color: var(--secondary-btn-text);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .status {
      margin: 20px 0 12px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .cards {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 8px 20px var(--card-shadow);
    }

    .card h3 {
      margin: 0;
      font-size: 1rem;
      color: var(--text);
    }

    .card time {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .card p {
      margin: 0;
      color: var(--text);
      line-height: 1.5;
    }

    .tag {
      background: var(--tag-bg);
      color: var(--tag-text);
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      display: inline-flex;
      align-items: center;
      width: fit-content;
    }

    .expandable button {
      align-self: flex-start;
      background: transparent;
      color: var(--accent);
      padding: 0;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: var(--modal-overlay);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 20;
    }

    .modal.is-open {
      display: flex;
    }

    .modal-content {
      background: var(--card);
      border-radius: 18px;
      max-width: 920px;
      width: 100%;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border);
      box-shadow: 0 20px 50px var(--modal-shadow);
    }

    .modal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
      padding: 20px 24px 12px;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.2rem;
      color: var(--text);
    }

    .modal-body {
      padding: 0 24px 24px;
      overflow-y: auto;
    }

    .modal-body p {
      white-space: pre-wrap;
      line-height: 1.65;
      color: var(--text);
    }

    .modal-close {
      background: transparent;
      color: var(--muted);
      font-size: 1.2rem;
      padding: 0;
    }

    .modal-footer {
      padding: 16px 24px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: center;
      gap: 12px;
    }

    .disclaimer-modal-content {
      max-width: 500px;
    }

    .modal-meta {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-top: 6px;
      color: var(--muted);
      font-size: 0.85rem;
    }

    .empty {
      padding: 40px;
      text-align: center;
      color: var(--muted);
      border: 2px dashed var(--border);
      border-radius: 16px;
    }

    .cache-info {
      margin-top: 32px;
      padding-top: 24px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    .cache-status {
      font-size: 0.85rem;
      color: var(--muted);
      text-align: center;
    }

    .refresh-btn {
      background: transparent;
      color: var(--muted);
      border: 1px solid var(--border);
      padding: 8px 14px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .refresh-btn:hover {
      background: var(--border);
      color: var(--text);
    }

    .radio-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .radio-label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      color: var(--text);
    }

    .radio-label input[type="radio"] {
      cursor: pointer;
      width: 14px;
      height: 14px;
    }

    .radio-label span {
      user-select: none;
    }

    mark {
      background-color: var(--highlight-bg);
      color: var(--highlight-text);
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: 600;
    }

    .no-results {
      margin: 20px 0;
      padding: 32px 24px;
      background: var(--error-bg);
      border: 2px solid var(--error-border);
      border-radius: 16px;
      text-align: center;
    }

    .no-results-content {
      max-width: 600px;
      margin: 0 auto;
    }

    .no-results-title {
      margin: 0 0 12px;
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--error-title);
    }

    .no-results-text {
      margin: 0;
      font-size: 0.95rem;
      color: var(--error-text);
      line-height: 1.6;
    }

    .search-group {
      flex: 2;
      min-width: 200px;
    }

    .theme-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
      margin-top: 16px;
      padding: 12px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .theme-toggle-btn {
      background: var(--border);
      color: var(--text);
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    .theme-toggle-btn:hover {
      background: var(--accent);
      color: #fff;
    }

    .theme-toggle-btn.active {
      background: var(--accent);
      color: #fff;
    }

    @media (max-width: 600px) {
      header {
        padding: 28px 18px 16px;
      }

      main {
        padding: 18px;
      }

      .controls {
        margin-top: -24px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>CQ Line Pilot Intel</h1>
    <p>Filter and review the latest CQ line pilot comments in a cleaner, responsive layout.</p>
  </header>
  <main>
    <section class="controls">
      <div class="control-group">
        <label for="startDate">Start date</label>
        <input type="date" id="startDate" />
      </div>
      <div class="control-group">
        <label for="endDate">End date</label>
        <input type="date" id="endDate" />
      </div>
      <div class="control-group">
        <label for="sortOrder">Sort by date</label>
        <select id="sortOrder">
          <option value="newest">Newest first</option>
          <option value="oldest">Oldest first</option>
        </select>
      </div>
      <div class="control-group search-group">
        <label for="searchInput">Search comments</label>
        <input type="text" id="searchInput" placeholder="Search keywords or &quot;exact phrase&quot;" />
      </div>
      <div class="control-group">
        <label>Search scope</label>
        <div class="radio-group">
          <label class="radio-label">
            <input type="radio" name="searchScope" value="filtered" checked />
            <span>Filtered comments</span>
          </label>
          <label class="radio-label">
            <input type="radio" name="searchScope" value="all" />
            <span>All comments</span>
          </label>
        </div>
      </div>
      <div class="actions">
        <button id="applyFilters">Apply filters</button>
        <button id="resetFilters" class="secondary">Reset</button>
      </div>
    </section>
    <section class="manual-input">
      <div class="control-group">
        <label for="sourceUrl">Fetch HTML from a URL (optional)</label>
        <input
          type="url"
          id="sourceUrl"
          placeholder="http://www.airbusdriver.net/airbus_CQT_Intel.htm"
          value="http://www.airbusdriver.net/airbus_CQT_Intel.htm"
        />
        <small class="status">If the request is blocked by CORS, download the HTML and paste it below.</small>
      </div>
      <div class="actions">
        <button id="fetchUrl" class="secondary">Fetch URL</button>
      </div>
      <div class="control-group">
        <label for="manualHtml">Paste HTML from the target page</label>
        <textarea id="manualHtml" placeholder="Paste the HTML source for http://www.airbusdriver.net/airbus_CQT_Intel.htm"></textarea>
      </div>
      <div class="actions">
        <button id="parseHtml" class="secondary">Parse pasted HTML</button>
      </div>
    </section>

    <div class="status" id="status">Paste the HTML source to load entries.</div>
    <div id="noResultsMessage" class="no-results" style="display: none;">
      <div class="no-results-content">
        <p class="no-results-title">No comments found</p>
        <p class="no-results-text" id="noResultsText"></p>
      </div>
    </div>
    <section class="cards" id="cards"></section>

    <footer class="cache-info">
      <div id="cacheStatus" class="cache-status"></div>
      <button id="refreshDataBtn" class="refresh-btn" style="display: none;">Refresh Data</button>
      <div class="theme-toggle">
        <span>Theme:</span>
        <button class="theme-toggle-btn" id="themeAuto">Auto</button>
        <button class="theme-toggle-btn" id="themeLight">Light</button>
        <button class="theme-toggle-btn" id="themeDark">Dark</button>
      </div>
    </footer>
  </main>

  <div class="modal" id="entryModal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal-header">
        <div>
          <h2 id="modalTitle">Entry details</h2>
          <div class="modal-meta" id="modalMeta"></div>
        </div>
        <button class="modal-close" id="closeModal" type="button" aria-label="Close full entry">
          ✕
        </button>
      </div>
      <div class="modal-body">
        <p id="modalBody"></p>
      </div>
    </div>
  </div>

  <div class="modal" id="disclaimerModal" aria-hidden="false">
    <div class="modal-content disclaimer-modal-content" role="dialog" aria-modal="true" aria-labelledby="disclaimerTitle">
      <div class="modal-header">
        <h2 id="disclaimerTitle">Welcome</h2>
      </div>
      <div class="modal-body">
        <p>This site is simply a modern mobile-friendly viewer for the AirBusDriver.net CQ comments. All comments are pulled directly from the original site without modification.</p>
      </div>
      <div class="modal-footer">
        <button id="disclaimerAccept">I understand</button>
      </div>
    </div>
  </div>

  <script>
    const statusEl = document.getElementById("status");
    const cardsEl = document.getElementById("cards");
    const startDateEl = document.getElementById("startDate");
    const endDateEl = document.getElementById("endDate");
    const sortOrderEl = document.getElementById("sortOrder");
    const applyFiltersBtn = document.getElementById("applyFilters");
    const resetFiltersBtn = document.getElementById("resetFilters");
    const fetchUrlBtn = document.getElementById("fetchUrl");
    const sourceUrlEl = document.getElementById("sourceUrl");
    const parseHtmlBtn = document.getElementById("parseHtml");
    const manualHtmlEl = document.getElementById("manualHtml");
    const searchInputEl = document.getElementById("searchInput");
    const searchScopeEls = document.getElementsByName("searchScope");

    // Initialize date inputs with calculated values
    const initializeDateInputs = () => {
      const today = new Date();

      // endDate: current date in user's local time
      const endDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const endDateString = endDate.toISOString().split('T')[0];
      endDateEl.value = endDateString;

      // startDate: December 1st of previous year
      const startDate = new Date(today.getFullYear() - 1, 11, 1); // Month is 0-indexed, so 11 = December
      const startDateString = startDate.toISOString().split('T')[0];
      startDateEl.value = startDateString;
    };

    // Call initialization immediately
    initializeDateInputs();

    // Sort preference persistence
    const SORT_PREFERENCE_KEY = "airbusdriver_sort_preference";

    const loadSortPreference = () => {
      try {
        const savedSort = localStorage.getItem(SORT_PREFERENCE_KEY);
        if (savedSort && sortOrderEl) {
          sortOrderEl.value = savedSort;
        }
      } catch (e) {
        console.error('[Sort] Failed to load sort preference:', e);
      }
    };

    const saveSortPreference = (value) => {
      try {
        localStorage.setItem(SORT_PREFERENCE_KEY, value);
      } catch (e) {
        console.error('[Sort] Failed to save sort preference:', e);
      }
    };

    // Load saved sort preference
    loadSortPreference();

    const PROXY_URL = "https://snowy-king-2ff2.phantomworx.workers.dev/";
    const entryModalEl = document.getElementById("entryModal");
    const closeModalBtn = document.getElementById("closeModal");
    const modalTitleEl = document.getElementById("modalTitle");
    const modalMetaEl = document.getElementById("modalMeta");
    const modalBodyEl = document.getElementById("modalBody");

    let allEntries = [];
    let lastCachedTimestamp = null;
    let searchTerms = [];
    let searchScope = 'filtered';

    const markerText = "Your CQ Line Pilot Comments will be placed here ...";

    // Cache configuration
    const CACHE_KEY = "airbusdriver_cache";
    const CACHE_EXPIRATION_MS = 24 * 60 * 60 * 1000; // 24 hours
    const DOUBLE_REFRESH_THRESHOLD_MS = 15 * 1000; // 15 seconds

    // localStorage cache functions
    const saveToCache = (html, entries, sourceUrl) => {
      try {
        const cacheData = {
          html,
          entries,
          timestamp: Date.now(),
          sourceUrl
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
        lastCachedTimestamp = cacheData.timestamp;
        updateCacheStatus();
        console.log('[Cache] Data saved to localStorage');
      } catch (e) {
        console.error('[Cache] Failed to save to localStorage:', e);
      }
    };

    const loadFromCache = () => {
      try {
        const cached = localStorage.getItem(CACHE_KEY);
        if (!cached) {
          console.log('[Cache] No cached data found');
          return null;
        }

        const cacheData = JSON.parse(cached);

        // Validate cache structure
        if (!cacheData.timestamp || !cacheData.html || !cacheData.entries) {
          console.log('[Cache] Invalid cache structure');
          return null;
        }

        // Check if cache is expired
        const age = Date.now() - cacheData.timestamp;
        if (age > CACHE_EXPIRATION_MS) {
          console.log('[Cache] Cache expired (age: ' + Math.round(age / 1000 / 60) + ' minutes)');
          return null;
        }

        // Rehydrate Date objects (JSON.stringify converts them to strings)
        cacheData.entries = cacheData.entries.map(entry => ({
          ...entry,
          date: entry.date ? new Date(entry.date) : null
        }));

        console.log('[Cache] Using cached data (age: ' + Math.round(age / 1000 / 60) + ' minutes)');
        lastCachedTimestamp = cacheData.timestamp;
        return cacheData;
      } catch (e) {
        console.error('[Cache] Failed to load from localStorage:', e);
        return null;
      }
    };

    const clearCache = () => {
      try {
        localStorage.removeItem(CACHE_KEY);
        lastCachedTimestamp = null;
        console.log('[Cache] Cache cleared');
      } catch (e) {
        console.error('[Cache] Failed to clear cache:', e);
      }
    };

    // sessionStorage double-refresh detection
    const checkDoubleRefresh = () => {
      try {
        const lastFetchTime = sessionStorage.getItem('lastFetchTime');
        const now = Date.now();

        if (lastFetchTime) {
          const timeSinceLastFetch = now - parseInt(lastFetchTime, 10);
          if (timeSinceLastFetch < DOUBLE_REFRESH_THRESHOLD_MS) {
            console.log('[Cache] Double-refresh detected! Forcing cache bypass.');
            return true;
          }
        }

        sessionStorage.setItem('lastFetchTime', now.toString());
        return false;
      } catch (e) {
        console.error('[Cache] Failed to check double-refresh:', e);
        return false;
      }
    };

    // Update cache status UI
    const updateCacheStatus = () => {
      const cacheStatusEl = document.getElementById('cacheStatus');
      const refreshBtn = document.getElementById('refreshDataBtn');

      if (!cacheStatusEl) return;

      if (lastCachedTimestamp) {
        const age = Date.now() - lastCachedTimestamp;
        const hours = Math.floor(age / 1000 / 60 / 60);
        const minutes = Math.floor((age / 1000 / 60) % 60);

        let ageText;
        if (hours > 0) {
          ageText = `${hours} hour${hours !== 1 ? 's' : ''}`;
          if (minutes > 0) {
            ageText += ` ${minutes} min`;
          }
        } else if (minutes > 0) {
          ageText = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
        } else {
          ageText = 'just now';
        }

        cacheStatusEl.textContent = `Last updated: ${ageText} ago`;
        if (refreshBtn) {
          refreshBtn.style.display = 'inline-block';
        }
      } else {
        cacheStatusEl.textContent = '';
        if (refreshBtn) {
          refreshBtn.style.display = 'none';
        }
      }
    };

    const normalizeWhitespace = (value) =>
      value.replace(/\s+/g, " ").trim();

    /**
     * Parse search query into terms
     * Handles quoted phrases as exact matches and space-separated keywords as OR logic
     * @param {string} query - The search query string
     * @returns {Array<{term: string, isExact: boolean}>} Array of search terms
     */
    const parseSearchQuery = (query) => {
      if (!query || !query.trim()) {
        return [];
      }

      const terms = [];
      const normalized = query.trim();

      // Extract quoted phrases first
      const quoteRegex = /"([^"]+)"/g;
      let match;
      let processedQuery = normalized;

      while ((match = quoteRegex.exec(normalized)) !== null) {
        const phrase = match[1].trim();
        if (phrase) {
          terms.push({ term: phrase, isExact: true });
        }
      }

      // Remove quoted phrases from the query
      processedQuery = processedQuery.replace(quoteRegex, ' ').trim();

      // Extract individual keywords (space-separated)
      if (processedQuery) {
        const keywords = processedQuery.split(/\s+/).filter(k => k.length > 0);
        keywords.forEach(keyword => {
          terms.push({ term: keyword, isExact: false });
        });
      }

      return terms;
    };

    /**
     * Filter entries by search terms (searches both content and date)
     * Uses OR logic - matches if ANY term is found
     * @param {Array} entries - Array of entry objects
     * @param {Array<{term: string, isExact: boolean}>} searchTerms - Parsed search terms
     * @returns {Array} Filtered entries
     */
    const filterBySearch = (entries, searchTerms) => {
      if (!searchTerms || searchTerms.length === 0) {
        return entries;
      }

      return entries.filter(entry => {
        const searchableText = `${entry.content} ${entry.dateText}`.toLowerCase();

        // Match if ANY term is found (OR logic)
        return searchTerms.some(({ term, isExact }) => {
          const lowerTerm = term.toLowerCase();

          if (isExact) {
            // Exact phrase match (case-insensitive)
            return searchableText.includes(lowerTerm);
          } else {
            // Keyword match (case-insensitive)
            return searchableText.includes(lowerTerm);
          }
        });
      });
    };

    /**
     * Highlight search keywords in text by wrapping them in <mark> tags
     * @param {string} text - The text to highlight
     * @param {Array<{term: string, isExact: boolean}>} searchTerms - Parsed search terms
     * @returns {string} Text with <mark> tags around matched terms
     */
    const highlightKeywords = (text, searchTerms) => {
      if (!text || !searchTerms || searchTerms.length === 0) {
        return text;
      }

      let result = text;

      // Sort terms by length (longest first) to avoid partial replacements
      const sortedTerms = [...searchTerms].sort((a, b) => b.term.length - a.term.length);

      sortedTerms.forEach(({ term }) => {
        // Create a regex that matches the term case-insensitively
        // Use word boundary for better matching, but allow partial matches too
        const regex = new RegExp(`(${escapeRegex(term)})`, 'gi');
        result = result.replace(regex, '<mark>$1</mark>');
      });

      return result;
    };

    /**
     * Escape special regex characters
     * @param {string} str - String to escape
     * @returns {string} Escaped string
     */
    const escapeRegex = (str) => {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    };

    /**
     * Get context excerpt around the first occurrence of search terms
     * @param {string} content - The full content
     * @param {Array<{term: string, isExact: boolean}>} searchTerms - Parsed search terms
     * @param {number} wordsAround - Number of words to show before/after the match
     * @returns {string} Context excerpt with ellipsis if truncated
     */
    const getSearchContext = (content, searchTerms, wordsAround = 15) => {
      if (!content || !searchTerms || searchTerms.length === 0) {
        return content;
      }

      const lowerContent = content.toLowerCase();
      let firstMatchIndex = -1;
      let matchLength = 0;

      // Find the first occurrence of any search term
      searchTerms.forEach(({ term }) => {
        const lowerTerm = term.toLowerCase();
        const index = lowerContent.indexOf(lowerTerm);

        if (index !== -1 && (firstMatchIndex === -1 || index < firstMatchIndex)) {
          firstMatchIndex = index;
          matchLength = term.length;
        }
      });

      // If no match found, return original content (shouldn't happen as filterBySearch already matched)
      if (firstMatchIndex === -1) {
        return content;
      }

      // Split content into words while preserving positions
      const words = content.split(/(\s+)/); // Include whitespace in the split
      let charCount = 0;
      let matchWordIndex = -1;

      // Find which word index contains the match
      for (let i = 0; i < words.length; i++) {
        const wordLen = words[i].length;
        if (charCount <= firstMatchIndex && firstMatchIndex < charCount + wordLen) {
          matchWordIndex = i;
          break;
        }
        charCount += wordLen;
      }

      if (matchWordIndex === -1) {
        return content; // Fallback
      }

      // Count actual words (not whitespace)
      const isWord = (w) => w.trim().length > 0;

      // Find start position (wordsAround words before match)
      let startIndex = matchWordIndex;
      let wordsBefore = 0;
      for (let i = matchWordIndex - 1; i >= 0 && wordsBefore < wordsAround; i--) {
        if (isWord(words[i])) {
          wordsBefore++;
          startIndex = i;
        }
      }

      // Find end position (wordsAround words after match)
      let endIndex = matchWordIndex;
      let wordsAfter = 0;
      for (let i = matchWordIndex + 1; i < words.length && wordsAfter < wordsAround; i++) {
        if (isWord(words[i])) {
          wordsAfter++;
          endIndex = i;
        }
      }

      // Extract the excerpt
      const excerpt = words.slice(startIndex, endIndex + 1).join('');

      // Add ellipsis if truncated
      const prefix = startIndex > 0 ? '...' : '';
      const suffix = endIndex < words.length - 1 ? '...' : '';

      return prefix + excerpt.trim() + suffix;
    };

    const cleanDateText = (text) =>
      text
        .replace(/\([^)]*\)/g, "")
        .replace(/\s+/g, " ")
        .trim();

    const parseDate = (text) => {
      if (!text) {
        return null;
      }

      const cleanedText = cleanDateText(text);
      let parsed = new Date(cleanedText);
      if (!Number.isNaN(parsed.getTime())) {
        return parsed;
      }

      const numericOnly = cleanedText.replace(/[^0-9/.-]/g, "").trim();
      if (!numericOnly) {
        return null;
      }

      parsed = new Date(numericOnly);
      if (!Number.isNaN(parsed.getTime())) {
        return parsed;
      }

      const match = numericOnly.match(/(\d{1,2})[\/.-](\d{1,2})[\/.-](\d{2,4})/);
      if (match) {
        const month = Number(match[1]);
        const day = Number(match[2]);
        let year = Number(match[3]);
        if (year < 100) {
          year += 2000;
        }
        parsed = new Date(year, month - 1, day);
        if (!Number.isNaN(parsed.getTime())) {
          return parsed;
        }
      }

      const monthYear = numericOnly.match(/(\d{1,2})[\/.-](\d{4})/);
      if (monthYear) {
        const month = Number(monthYear[1]);
        const year = Number(monthYear[2]);
        parsed = new Date(year, month - 1, 1);
        if (!Number.isNaN(parsed.getTime())) {
          return parsed;
        }
      }

      return null;
    };

    const formatDate = (date, fallback) => {
      if (!date) {
        return fallback || "Unknown date";
      }
      return date.toLocaleDateString(undefined, {
        year: "numeric",
        month: "short",
        day: "2-digit",
      });
    };

    const getEntriesFromDocument = (doc) => {
      const rows = Array.from(doc.querySelectorAll("tr"));
      const markerIndex = rows.findIndex((row) =>
        normalizeWhitespace(row.textContent).includes(markerText)
      );

      if (markerIndex === -1) {
        return [];
      }

      const entries = [];
      const dataRows = rows.slice(markerIndex + 1);

      dataRows.forEach((row) => {
        const strong = row.querySelector("strong");
        if (!strong) {
          return;
        }

        const dateText = normalizeWhitespace(strong.textContent);
        const date = parseDate(dateText);
        
        if (!date) {
          return;
        }

        // Extract content preserving <br> as newlines
        let content = row.innerHTML;
        // Remove the strong element from the content
        const strongHtml = strong.outerHTML;
        content = content.replace(strongHtml, "").trim();
        
        // Use a placeholder for <br> tags to preserve them
        const BR_PLACEHOLDER = "|||BREAK|||";
        content = content.replace(/<br\s*\/?>/gi, BR_PLACEHOLDER);
        
        // Remove all remaining HTML tags
        content = content.replace(/<[^>]*>/g, "");
        
        // Split by the break placeholder to handle each segment
        const segments = content.split(BR_PLACEHOLDER);
        
        // Clean each segment but keep empty ones (for double breaks)
        const cleanedSegments = segments
          .map((segment) => normalizeWhitespace(segment));
        
        // Rejoin with newlines, preserving empty segments for double breaks
        content = cleanedSegments.join("\n").trim();

        if (!content) {
          return;
        }

        entries.push({
          dateText,
          date,
          content,
        });
      });

      return entries;
    };

    const parseEntriesFromHtml = (html) => {
      const doc = new DOMParser().parseFromString(html, "text/html");
      return getEntriesFromDocument(doc);
    };

    const fetchHtmlFromUrl = async (url) => {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch (${response.status} ${response.statusText})`);
      }
      return response.text();
    };

    const describeFetchError = (error, url) => {
      const reason = error instanceof Error ? error.message : String(error);
      return `Unable to fetch ${url}. ${reason}. This is often caused by CORS or a blocked origin.`;
    };

    // Fallback removed — proxy will be used for all fetches

    const buildProxyUrl = (proxyBase, targetUrl) => {
      const trimmed = proxyBase.trim();
      if (!trimmed) {
        return null;
      }
      if (trimmed.includes("?")) {
        return `${trimmed}${encodeURIComponent(targetUrl)}`;
      }
      return `${trimmed}?url=${encodeURIComponent(targetUrl)}`;
    };

    const fetchWithProxy = async (targetUrl, forceRefresh = false) => {
      const proxyUrl = buildProxyUrl(PROXY_URL, targetUrl);
      if (!proxyUrl) {
        throw new Error("No proxy URL configured.");
      }

      // Add Cache-Control header for force refresh
      const headers = forceRefresh ? { 'Cache-Control': 'no-cache' } : {};

      const response = await fetch(proxyUrl, { headers });
      if (!response.ok) {
        throw new Error(`Failed to fetch (${response.status} ${response.statusText})`);
      }
      return response.text();
    };

    const isWithinRange = (entry) => {
      const startValue = startDateEl.value ? new Date(startDateEl.value) : null;
      const endValue = endDateEl.value ? new Date(endDateEl.value) : null;

      if (!startValue && !endValue) {
        return true;
      }

      if (!entry.date) {
        return true;
      }

      if (startValue && entry.date < startValue) {
        return false;
      }

      if (endValue) {
        const inclusiveEnd = new Date(endValue);
        inclusiveEnd.setHours(23, 59, 59, 999);
        if (entry.date > inclusiveEnd) {
          return false;
        }
      }

      return true;
    };

    const createCard = (entry) => {
      const card = document.createElement("article");
      card.className = "card";

      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = entry.dateText || "Unknown date";

      const textWrap = document.createElement("div");
      textWrap.className = "expandable";

      const paragraph = document.createElement("p");
      const fullText = entry.content;
      const maxLength = 260;

      // Show search context excerpt if searching, otherwise show normal preview
      const updateText = () => {
        let text;

        if (searchTerms.length > 0) {
          // Get context excerpt around search term
          text = getSearchContext(fullText, searchTerms, 15);
          // Highlight keywords in the excerpt
          const highlightedText = highlightKeywords(text, searchTerms);
          paragraph.innerHTML = highlightedText;
        } else {
          // Normal preview: first few lines (up to 3)
          const lines = fullText.split("\n");
          const preview = lines.slice(0, 3).join("\n");
          text = preview;
          if (text.length > maxLength) {
            text = `${text.slice(0, maxLength).trim()}…`;
          }
          paragraph.textContent = text;
        }

        paragraph.style.whiteSpace = "pre-wrap";
      };

      updateText();

      textWrap.appendChild(paragraph);

      const expandBtn = document.createElement("button");
      expandBtn.type = "button";
      expandBtn.textContent = "View full report";
      expandBtn.addEventListener("click", () => openModal(entry));
      textWrap.appendChild(expandBtn);
      // Make entire card clickable to open modal
card.addEventListener("click", (e) => {
  // Don't trigger if clicking the button (it has its own handler)
  if (e.target !== expandBtn) {
    openModal(entry);
  }
});
card.style.cursor = "pointer";

      card.appendChild(tag);
      card.appendChild(textWrap);

      return card;
    };

    const openModal = (entry) => {
      modalTitleEl.textContent = entry.dateText || "Full entry";
      modalMetaEl.textContent = formatDate(entry.date, entry.dateText);
      // Clear previous content
      modalBodyEl.innerHTML = "";

      if (searchTerms.length > 0) {
        // Highlight keywords in full content
        const lines = entry.content.split("\n");
        lines.forEach((line, index) => {
          if (index > 0) {
            modalBodyEl.appendChild(document.createElement("br"));
          }
          // Highlight keywords in each line
          if (line.length > 0) {
            const highlightedLine = highlightKeywords(line, searchTerms);
            const span = document.createElement("span");
            span.innerHTML = highlightedLine;
            modalBodyEl.appendChild(span);
          }
        });
      } else {
        // No search - show normal content
        const lines = entry.content.split("\n");
        lines.forEach((line, index) => {
          if (index > 0) {
            modalBodyEl.appendChild(document.createElement("br"));
          }
          // Add text node even if line is empty (for double <br> support)
          if (line.length > 0) {
            modalBodyEl.appendChild(document.createTextNode(line));
          }
        });
      }

      entryModalEl.classList.add("is-open");
      entryModalEl.setAttribute("aria-hidden", "false");
    };

    const closeModal = () => {
      entryModalEl.classList.remove("is-open");
      entryModalEl.setAttribute("aria-hidden", "true");
    };

    const renderEntries = () => {
      const noResultsEl = document.getElementById('noResultsMessage');
      const noResultsTextEl = document.getElementById('noResultsText');

      // Step 1: Get base entries based on search scope
      let baseEntries;
      if (searchTerms.length > 0 && searchScope === 'all') {
        // Search all comments (ignore date filter)
        baseEntries = allEntries;
      } else {
        // Apply date filter
        baseEntries = allEntries.filter(isWithinRange);
      }

      // Step 2: Apply search filtering
      let visibleEntries = filterBySearch(baseEntries, searchTerms);

      // Step 3: Apply sorting
      const sortOrder = sortOrderEl ? sortOrderEl.value : 'newest';
      visibleEntries.sort((a, b) => {
        // Handle entries without dates (should be rare, but just in case)
        if (!a.date && !b.date) return 0;
        if (!a.date) return 1; // Put entries without dates at the end
        if (!b.date) return -1;

        // Sort by date
        if (sortOrder === 'oldest') {
          return a.date - b.date; // Ascending (oldest first)
        } else {
          return b.date - a.date; // Descending (newest first)
        }
      });

      // Step 4: Update status
      if (searchTerms.length > 0) {
        const totalCount = searchScope === 'all' ? allEntries.length : baseEntries.length;
        statusEl.textContent = `${visibleEntries.length} of ${totalCount} comments match your search.`;
      } else {
        statusEl.textContent = `${visibleEntries.length} entries loaded.`;
      }

      // Step 5: Handle no results
      if (visibleEntries.length === 0) {
        cardsEl.innerHTML = "";

        if (searchTerms.length > 0) {
          // Show search-specific no results message
          noResultsEl.style.display = 'block';

          if (searchScope === 'filtered') {
            noResultsTextEl.textContent =
              'No comments match your search within the selected date range. Try searching "All comments" to expand your search.';
          } else {
            noResultsTextEl.textContent =
              'No comments match your search terms.';
          }
        } else {
          // Show date filter no results message
          noResultsEl.style.display = 'none';
          cardsEl.innerHTML = `
            <div class="empty">
              No entries match the selected date range.
            </div>
          `;
        }
        return;
      }

      // Step 6: Hide no results message and render cards
      noResultsEl.style.display = 'none';
      cardsEl.innerHTML = "";
      visibleEntries.forEach((entry) => {
        cardsEl.appendChild(createCard(entry));
      });
    };

    applyFiltersBtn.addEventListener("click", renderEntries);
    resetFiltersBtn.addEventListener("click", () => {
      startDateEl.value = "";
      endDateEl.value = "";
      searchInputEl.value = "";
      searchTerms = [];
      // Reset search scope to filtered
      searchScopeEls.forEach(radio => {
        if (radio.value === 'filtered') {
          radio.checked = true;
        }
      });
      searchScope = 'filtered';
      renderEntries();
    });

    // Handle sort order changes
    if (sortOrderEl) {
      sortOrderEl.addEventListener("change", () => {
        saveSortPreference(sortOrderEl.value);
        renderEntries();
      });
    }

    // Debounce utility function
    const debounce = (func, delay) => {
      let timeoutId;
      return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
      };
    };

    // Handle search input with debounce (300ms is standard best practice)
    const handleSearchInput = () => {
      const query = searchInputEl.value;
      searchTerms = parseSearchQuery(query);
      renderEntries();
    };

    const debouncedSearch = debounce(handleSearchInput, 300);

    if (searchInputEl) {
      searchInputEl.addEventListener("input", debouncedSearch);
    }

    // Handle search scope changes
    const handleSearchScopeChange = (e) => {
      searchScope = e.target.value;
      renderEntries();
    };

    if (searchScopeEls) {
      searchScopeEls.forEach(radio => {
        radio.addEventListener("change", handleSearchScopeChange);
      });
    }

    const fetchAndLoad = async (url, forceRefresh = false) => {
      const trimmed = url ? url.trim() : "";
      if (!trimmed) {
        statusEl.textContent = "Enter a URL to fetch.";
        return;
      }

      // Check for double-refresh (unless already forcing refresh)
      if (!forceRefresh) {
        forceRefresh = checkDoubleRefresh();
      }

      // Try to load from cache if not forcing refresh
      if (!forceRefresh) {
        const cached = loadFromCache();
        if (cached && cached.sourceUrl === trimmed) {
          console.log('[Cache] Loading from cache');
          manualHtmlEl.value = cached.html;
          allEntries = cached.entries;
          renderEntries();
          updateCacheStatus();
          return;
        }
      }

      // Cache miss or force refresh - fetch from network
      console.log('[Cache] Fetching from network' + (forceRefresh ? ' (forced)' : ''));
      statusEl.textContent = "Fetching HTML…";

      try {
        const html = await fetchHtmlFromUrl(trimmed);
        manualHtmlEl.value = html;
        allEntries = parseEntriesFromHtml(html);
        saveToCache(html, allEntries, trimmed);
        renderEntries();
        return;
      } catch (error) {
        statusEl.textContent = `${describeFetchError(error, trimmed)} Attempting proxy fetch…`;
        console.error(error);
        try {
          const html = await fetchWithProxy(trimmed, forceRefresh);
          manualHtmlEl.value = html;
          allEntries = parseEntriesFromHtml(html);
          saveToCache(html, allEntries, trimmed);
          renderEntries();
          return;
        } catch (proxyError) {
          statusEl.textContent = `${describeFetchError(proxyError, buildProxyUrl(PROXY_URL, trimmed) || "proxy URL")} Paste the HTML source instead.`;
          console.error(proxyError);
        }
      }
    };

    fetchUrlBtn.addEventListener("click", async () => {
      await fetchAndLoad(sourceUrlEl.value);
    });

    // Auto-fetch on page load using the configured source URL
    window.addEventListener("load", () => {
      try {
        const url = sourceUrlEl && sourceUrlEl.value ? sourceUrlEl.value.trim() : "";
        if (url) {
          fetchAndLoad(url);
        }
      } catch (e) {
        console.error("Auto-fetch failed:", e);
      }
    });
    parseHtmlBtn.addEventListener("click", () => {
      const html = manualHtmlEl.value.trim();
      if (!html) {
        statusEl.textContent = "Paste the HTML source to parse it.";
        return;
      }
      allEntries = parseEntriesFromHtml(html);
      renderEntries();
    });
    closeModalBtn.addEventListener("click", closeModal);
    entryModalEl.addEventListener("click", (event) => {
      if (event.target === entryModalEl) {
        closeModal();
      }
    });
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && entryModalEl.classList.contains("is-open")) {
        closeModal();
      }
    });

    // Refresh button handler
    const refreshDataBtn = document.getElementById('refreshDataBtn');
    if (refreshDataBtn) {
      refreshDataBtn.addEventListener('click', async () => {
        const url = sourceUrlEl && sourceUrlEl.value ? sourceUrlEl.value.trim() : "";
        if (url) {
          clearCache();
          await fetchAndLoad(url, true); // Force refresh
        }
      });
    }

    // Update cache status every minute
    setInterval(updateCacheStatus, 60000);

    // Disclaimer modal handling
    const DISCLAIMER_KEY = "airbusdriver_disclaimer_accepted";
    const disclaimerModalEl = document.getElementById("disclaimerModal");
    const disclaimerAcceptBtn = document.getElementById("disclaimerAccept");

    const checkAndShowDisclaimer = () => {
      try {
        const accepted = localStorage.getItem(DISCLAIMER_KEY);
        if (!accepted) {
          // Show the modal
          disclaimerModalEl.classList.add("is-open");
          disclaimerModalEl.setAttribute("aria-hidden", "false");
        } else {
          // Hide the modal
          disclaimerModalEl.classList.remove("is-open");
          disclaimerModalEl.setAttribute("aria-hidden", "true");
        }
      } catch (e) {
        console.error('[Disclaimer] Failed to check disclaimer status:', e);
      }
    };

    const closeDisclaimer = () => {
      try {
        localStorage.setItem(DISCLAIMER_KEY, "true");
        disclaimerModalEl.classList.remove("is-open");
        disclaimerModalEl.setAttribute("aria-hidden", "true");
      } catch (e) {
        console.error('[Disclaimer] Failed to save disclaimer acceptance:', e);
      }
    };

    // Check on page load
    checkAndShowDisclaimer();

    // Handle accept button
    if (disclaimerAcceptBtn) {
      disclaimerAcceptBtn.addEventListener("click", closeDisclaimer);
    }

    // Theme management
    const THEME_KEY = "airbusdriver_theme_preference";
    const themeAutoBtn = document.getElementById("themeAuto");
    const themeLightBtn = document.getElementById("themeLight");
    const themeDarkBtn = document.getElementById("themeDark");

    const getSystemPreference = () => {
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return 'dark';
      }
      return 'light';
    };

    const applyTheme = (theme) => {
      const root = document.documentElement;

      if (theme === 'auto') {
        const systemTheme = getSystemPreference();
        root.setAttribute('data-theme', systemTheme);
      } else {
        root.setAttribute('data-theme', theme);
      }

      // Update active button state
      [themeAutoBtn, themeLightBtn, themeDarkBtn].forEach(btn => {
        btn.classList.remove('active');
      });

      if (theme === 'auto') {
        themeAutoBtn.classList.add('active');
      } else if (theme === 'light') {
        themeLightBtn.classList.add('active');
      } else if (theme === 'dark') {
        themeDarkBtn.classList.add('active');
      }
    };

    const loadThemePreference = () => {
      try {
        const savedTheme = localStorage.getItem(THEME_KEY);
        return savedTheme || 'auto'; // Default to auto
      } catch (e) {
        console.error('[Theme] Failed to load theme preference:', e);
        return 'auto';
      }
    };

    const saveThemePreference = (theme) => {
      try {
        localStorage.setItem(THEME_KEY, theme);
      } catch (e) {
        console.error('[Theme] Failed to save theme preference:', e);
      }
    };

    // Apply saved theme on load
    const initialTheme = loadThemePreference();
    applyTheme(initialTheme);

    // Handle theme button clicks
    if (themeAutoBtn) {
      themeAutoBtn.addEventListener('click', () => {
        saveThemePreference('auto');
        applyTheme('auto');
      });
    }

    if (themeLightBtn) {
      themeLightBtn.addEventListener('click', () => {
        saveThemePreference('light');
        applyTheme('light');
      });
    }

    if (themeDarkBtn) {
      themeDarkBtn.addEventListener('click', () => {
        saveThemePreference('dark');
        applyTheme('dark');
      });
    }

    // Listen for system theme changes when in auto mode
    if (window.matchMedia) {
      const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');
      darkModeQuery.addEventListener('change', () => {
        const currentTheme = loadThemePreference();
        if (currentTheme === 'auto') {
          applyTheme('auto');
        }
      });
    }
  </script>
</body>
</html>
